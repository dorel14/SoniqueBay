"""Add more infos to all tables

Revision ID: ca62d38d2df4
Revises: 0b30bda5245f
Create Date: 2025-05-17 19:42:12.561226

"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql, mysql, sqlite  # noqa: F401


# revision identifiers, used by Alembic.
revision: str = 'ca62d38d2df4'
down_revision: Union[str, None] = '0b30bda5245f'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def get_create_table_sql(dialect_name):
    """Retourne le SQL adapté au dialecte."""
    if dialect_name == 'postgresql':
        auto_increment = "SERIAL"
        timestamp = "TIMESTAMP WITH TIME ZONE"
    elif dialect_name == 'mysql':
        auto_increment = "INTEGER AUTO_INCREMENT"
        timestamp = "DATETIME"
    else:  # sqlite
        auto_increment = "INTEGER"
        timestamp = "DATETIME"

    return f"""
        CREATE TABLE tracks_new (
            id {auto_increment} PRIMARY KEY,
            title VARCHAR(255),
            track_artist_id INTEGER NOT NULL,
            album_id INTEGER,
            path VARCHAR(255),
            duration INTEGER,
            featured_artists VARCHAR(255),
            year VARCHAR(10),
            genre VARCHAR(100),
            musicbrainz_id VARCHAR(50) UNIQUE,
            musicbrainz_albumid VARCHAR(50),
            musicbrainz_artistid VARCHAR(50),
            musicbrainz_albumartistid VARCHAR(50),
            musicbrainz_genre VARCHAR(100),
            cover_mime_type VARCHAR(50),
            file_type VARCHAR(50),
            bitrate INTEGER,
            date_added {timestamp} DEFAULT CURRENT_TIMESTAMP,
            date_modified {timestamp} DEFAULT CURRENT_TIMESTAMP,
            CONSTRAINT uq_tracks_path UNIQUE (path),
            CONSTRAINT uq_tracks_musicbrainz_id UNIQUE (musicbrainz_id),
            CONSTRAINT fk_tracks_track_artist_id FOREIGN KEY (track_artist_id) REFERENCES artists(id),
            CONSTRAINT fk_tracks_album_id FOREIGN KEY (album_id) REFERENCES albums(id)
        )
    """


def has_column(table_name: str, column_name: str) -> bool:
    """Check if a column exists in a table."""
    conn = op.get_bind()
    insp = sa.inspect(conn)
    has_column = False
    for col in insp.get_columns(table_name):
        if col['name'] == column_name:
            has_column = True
    return has_column


def has_table(table_name: str) -> bool:
    """Vérifie si une table existe."""
    conn = op.get_bind()
    insp = sa.inspect(conn)
    return insp.has_table(table_name)


def upgrade() -> None:
    """Upgrade schema with multi-db compatibility."""
    dialect_name = op.get_bind().dialect.name

    # 1. Supprimer toutes les tables temporaires potentielles
    for temp_table in ['_temp_tracks', 'tracks_new', '_alembic_tmp_tracks']:
        op.execute(f"DROP TABLE IF EXISTS {temp_table}")

    # 2. Créer une nouvelle table avec le bon schéma
    temp_table = '_temp_tracks'
    create_sql = get_create_table_sql(dialect_name)
    op.execute(create_sql.replace('tracks_new', temp_table))

    # 3. Copier les données si la table source existe
    if has_table('tracks'):
        op.execute(f"""
            INSERT INTO {temp_table} (
                id, title, track_artist_id, album_id, path, duration,
                date_added, date_modified
            )
            SELECT 
                id, title, artist_id, album_id, path, duration,
                date_added, date_modified
            FROM tracks;
        """)
        
        # 4. Supprimer l'ancienne table de façon sûre
        op.execute("DROP TABLE IF EXISTS tracks")

    # 5. Renommer la table temporaire
    op.execute(f"ALTER TABLE {temp_table} RENAME TO tracks")

    # 6. Ajouter les colonnes albums sans utiliser batch_alter_table
    op.execute("DROP TABLE IF EXISTS _alembic_tmp_albums")
    for column in [
        ("musicbrainz_albumartistid", "VARCHAR(50)"),
        ("genre", "VARCHAR(100)")
    ]:
        if not has_column('albums', column[0]):
            op.execute(f"ALTER TABLE albums ADD COLUMN {column[0]} {column[1]}")

    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('tracks', schema=None) as batch_op:
        batch_op.add_column(sa.Column('cover_url', sa.VARCHAR(), nullable=True))
        batch_op.add_column(sa.Column('mime_type', sa.VARCHAR(), nullable=True))
        batch_op.drop_constraint('fk_tracks_track_artist_id_artists', type_='foreignkey')
        batch_op.drop_column('featured_artists')
        batch_op.drop_column('track_artist_id')
        batch_op.drop_column('cover_mime_type')
        batch_op.drop_column('musicbrainz_genre')
        batch_op.drop_column('musicbrainz_albumartistid')
        batch_op.drop_column('musicbrainz_artistid')
        batch_op.drop_column('musicbrainz_albumid')
        batch_op.drop_column('genre')
        batch_op.drop_column('year')

    with op.batch_alter_table('albums', schema=None) as batch_op:
        batch_op.drop_column('genre')
        batch_op.drop_column('musicbrainz_albumartistid')

    # ### end Alembic commands ###
